package account

import (
	"encoding/json"
	"fmt"

	"github.com/TheThingsNetwork/ttn/core/account/client"
	"github.com/TheThingsNetwork/ttn/core/types"
	"github.com/apex/log"
)

// Account is a proxy to an account on the account server
type Account struct {
	client      *client.Client
	accessToken string
}

// New creates a new Account with the default HTTPClient
func New(accessToken string) Account {
	client := &client.New()
	return NewWithClient(accessToken, client)
}

// NewWithClient creates a new Account with a custom client
func NewWithClient(accessToken string, client *client.Client) Account {
	return Account{
		client:      client,
		accessToken: accessToken,
	}
}

// ListApplications list all applications
func (a *Account) ListApplications(ctx log.Interface) (apps []Application, err error) {
	resp, err := a.client.Get(a.accessToken, "/applications")
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	if err := decoder.Decode(&apps); err != nil {
		return nil, err
	}

	return apps
}

// GetApplication gets a specific application from the account server
func (a *Account) GetApplication(ctx log.Interface, appID string) (Application, error) {
	resp, err := a.client.Get(a.accessToken, fmt.Sprintf("/applications/%s", appID))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	if err := decoder.Decode(&apps); err != nil {
		return nil, err
	}

	return apps
}

type createApplicationReq struct {
	ID   string         `json:"id"`
	Name string         `json:"name"`
	EUIs []types.AppEUI `json:"euis,omitempty"`
}

// CreateApplication creates a new application on the account server
func (a *Account) CreateApplication(ctx log.Interface, appID string, name string, EUIs []types.AppEUI) (Application, error) {
	body := createApplicationReq{
		ID:   appID,
		Name: name,
		EUIs: EUIs,
	}

	resp, err := a.client.Post(a.accessToken, fmt.Sprintf("/applications", body))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	if err := decoder.Decode(&apps); err != nil {
		return nil, err
	}

	return apps
}

// DeleteApplication deletes an application
func (a *Account) DeleteAppliction(ctx log.Interface, appID string) error {
	resp, err := a.client.Delete(a.accessToken, fmt.Sprintf("/applications/%s", appID))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	decoder := json.NewDecoder(resp.Body)
	if err := decoder.Decode(&apps); err != nil {
		return nil, err
	}

	return apps
}

// Grant adds a collaborator to the application
func (a *Account) Grant(ctx log.Interface, appID string, username string, rights []Right) error {
	panic("Grant not implemented")
}

// Retract removes rights from a collaborator of the application
func (a *Account) Retract(ctx log.Interface, appID string, username string, rights []Right) error {
	panic("Retract not implemented")
}

// AddAccessKey
func (a *Account) AddAccessKey(ctx log.Interface, appID string, key AccessKey) error {
	panic("AddAccessKey not implemented")
}

// RemoveAccessKey
func (a *Account) RemoveAccessKey(ctx log.Interface, appID string, key AccessKey) error {
	panic("RemoveAccessKey not implemented")
}

// ChangeName
func (a *Account) ChangeName(ctx log.Interface, appID string, name string) error {
	panic("ChangeName not implemented")
}

// AddEUI
func (a *Account) AddEUI(ctx log.Interface, appID string, eui types.AppEUI) error {
	panic("AddEUI not implemented")
}

// RemoveEUI
func (a *Account) RemoveEUI(ctx log.Interface, appID string, eui types.AppEUI) error {
	panic("RemoveEUI not implemented")
}
